<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 on 子舒的博客</title>
    <link>https://zishu.me/tags/%E6%9D%82%E8%B0%88/</link>
    <description>Recent content in 杂谈 on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://zishu.me/tags/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>为什么getTime()返回1970年至今的毫秒？</title>
      <link>https://zishu.me/blog/16.html/</link>
      <pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zishu.me/blog/16.html/</guid>
      <description>今天在写new Date()时候，无意中发现了一个很有意思的方法，getTime()，百度了一下，有人说是计算从1970年1月1日至今的毫秒数 为什么要是1970年呢？ new Date().getTime(); // xxxxxxxxxxx 这个起源于unix的诞生，因为Unix在1969年被开发出来，1971年正式发布，在这之前没有机器会需要来表示1970-01-01-00:00:00之前的时间，后面的语言很多就沿用了这一习惯，js只是也沿用了这种习惯而已。 当然，这一做法现在看来是很有问题的，例如不方便用它表示更早的时间而且精度有限。 定义time从1970年1月1日开始，忽然想到在JAVA里，Oracle数据库时间也是从1970年1月1日开始计算。 比如java类代码: Date date = new Date(0); System.out.println(date); // 打印出来的结果：Thu Jan 01 08:00:00 CST 1970也 是1970年1月1日，实际上时分秒是0点0分0秒(这里打印出来是8点，稍后会作解释)。 为什么这个时间会定义在1970年1月1日这个时候呢? 于是开始了Google，中文网页根本找不到答案。于是试着搜索英文关键字,在Sun java论坛总算找到准确的帖子: http://forums.sun.com/thread.jspa?threadID=595140&amp;amp;start=15 其中有一个回复: I suspect that Java was born and raised on a UNIX system. UNIX considers the epoch (when did time begin) to be midnight, January 1, 1970. 是说java起源于UNIX系统，而UNIX认为1970年1月1日0点是时间纪元. 但这依然没很好的解释&amp;quot;为什么&amp;quot;,出于好奇，继续Google，总算找到了答案: http://en.wikipedia.org/wiki/Unix_time 这里的解释是: 最初计算机操作系统是32位，而时间也是用32位表示。 System.out.println(Integer.MAX_VALUE); 2147483647 Integer在JAVA内用32位表示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647/31536000 = 68.1,也就是说32位能表示的最长时间是68年，而实际上到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。 到这里，我想问题的答案已经出来了: 因为用32位来表示时间的最大间隔是68年，而最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)，而java自然也遵循了这一约束。 至于时间回归的现象相信随着64为操作系统的产生逐渐得到解决，因为用64位操作系统可以表示到292,277,026,596年12月4日15时30分08秒，相信我们的N代子孙，哪怕地球毁灭那天都不用愁不够用了，因为这个时间已经是千亿年以后了。 最后一个问题: 上面System.out.println(new Date(0))，打印出来的时间是8点而非0点，原因是存在系统时间和本地时间的问题，其实系统时间依然是0点，只不过我的电脑时区设置为东8区，故打印的结果是8点。</description>
    </item>
    
  </channel>
</rss>
