<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gravatar on 子舒的博客</title>
    <link>/tags/gravatar/</link>
    <description>Recent content in gravatar on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/gravatar/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用 cloudflare 反代 gravatar 免费生成国内镜像</title>
      <link>/blog/182.html/</link>
      <pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>/blog/182.html/</guid>
      <description>cloudflare 有一个非常好用的功能&amp;mdash;Workers，可以在无服务器的状态下运行一些程序，包括常见的反向代理等。 所以我利用这一功能实现对 gravatar 反代，达到国内访问加速的目的。 话不多说，开始流程操作，分享我的部署过程。 1.登陆后，在主页点击左侧的 Workers，然后点击创建服务。 2.服务名称随意填写，然后点击右下角创建。 3.点击右上角快速编辑 4.在左侧编辑器中输入下列的代码 点击展开代码 // 替换成你想镜像的站点 const upstream = &amp;#39;gravatar.com&amp;#39; // 如果那个站点有专门的移动适配站点，否则保持和上面一致 const upstream_mobile = &amp;#39;gravatar.com&amp;#39; // 你希望禁止哪些国家访问 const blocked_region = [] // 禁止自访问 const blocked_ip_address = [] // 替换成你想镜像的站点 const replace_dict = { &amp;#39;$upstream&amp;#39;: &amp;#39;$custom_domain&amp;#39;, &amp;#39;//gravatar.com&amp;#39;: &amp;#39;&amp;#39; } //以下内容都不用动 addEventListener(&amp;#39;fetch&amp;#39;, event =&amp;gt; { event.respondWith(fetchAndApply(event.request)); }) async function fetchAndApply(request) { const region = request.headers.get(&amp;#39;cf-ipcountry&amp;#39;).toUpperCase(); const ip_address = request.headers.get(&amp;#39;cf-connecting-ip&amp;#39;); const user_agent = request.headers.get(&amp;#39;user-agent&amp;#39;); let response = null; let url = new URL(request.url); let url_host = url.host; if (url.protocol == &amp;#39;http:&amp;#39;) { url.protocol = &amp;#39;https:&amp;#39; response = Response.redirect(url.href); return response; } if (await device_status(user_agent)) { upstream_domain = upstream } else { upstream_domain = upstream_mobile } url.host = upstream_domain; if (blocked_region.includes(region)) { response = new Response(&amp;#39;Access denied: WorkersProxy is not available in your region yet.&amp;#39;, { status: 403 }); } else if(blocked_ip_address.includes(ip_address)){ response = new Response(&amp;#39;Access denied: Your IP address is blocked by WorkersProxy.&amp;#39;, { status: 403 }); } else{ let method = request.method; let request_headers = request.headers; let new_request_headers = new Headers(request_headers); new_request_headers.set(&amp;#39;Host&amp;#39;, upstream_domain); new_request_headers.set(&amp;#39;Referer&amp;#39;, url.href); let original_response = await fetch(url.href, { method: method, headers: new_request_headers }) let original_response_clone = original_response.clone(); let original_text = null; let response_headers = original_response.headers; let new_response_headers = new Headers(response_headers); let status = original_response.status; new_response_headers.set(&amp;#39;access-control-allow-origin&amp;#39;, &amp;#39;*&amp;#39;); new_response_headers.set(&amp;#39;access-control-allow-credentials&amp;#39;, true); new_response_headers.delete(&amp;#39;content-security-policy&amp;#39;); new_response_headers.delete(&amp;#39;content-security-policy-report-only&amp;#39;); new_response_headers.delete(&amp;#39;clear-site-data&amp;#39;); const content_type = new_response_headers.get(&amp;#39;content-type&amp;#39;); if (content_type.includes(&amp;#39;text/html&amp;#39;) &amp;amp;&amp;amp; content_type.includes(&amp;#39;UTF-8&amp;#39;)) { original_text = await replace_response_text(original_response_clone, upstream_domain, url_host); } else { original_text = original_response_clone.body } response = new Response(original_text, { status, headers: new_response_headers }) } return response; } async function replace_response_text(response, upstream_domain, host_name) { let text = await response.text() var i, j; for (i in replace_dict) { j = replace_dict[i] if (i == &amp;#39;$upstream&amp;#39;) { i = upstream_domain } else if (i == &amp;#39;$custom_domain&amp;#39;) { i = host_name } if (j == &amp;#39;$upstream&amp;#39;) { j = upstream_domain } else if (j == &amp;#39;$custom_domain&amp;#39;) { j = host_name } let re = new RegExp(i, &amp;#39;g&amp;#39;) text = text.replace(re, j); } return text; } async function device_status (user_agent_info) { var agents = [&amp;#34;Android&amp;#34;, &amp;#34;iPhone&amp;#34;, &amp;#34;SymbianOS&amp;#34;, &amp;#34;Windows Phone&amp;#34;, &amp;#34;iPad&amp;#34;, &amp;#34;iPod&amp;#34;]; var flag = true; for (var v = 0; v &amp;lt; agents.length; v++) { if (user_agent_info.indexOf(agents[v]) &amp;gt; 0) { flag = false; break; } } return flag; } 然后点击保存并部署，就可以成功反代 gravatar 镜像了。 然后照葫芦画瓢，可以通过这种方式反代任何网站，我就使用 https://zsh.im 反代了我的国内博客 https://zburu.com。 访问起来大致无压力，延迟100+ms左右。 5.自定义域名 在触发器中可以找到自定义域名选项，输入已经绑定 cloudflare 的域名，再次赞美 cloudflare，如果事前绑定好了域名，在这里可以直接输入二级域名，cloudflare 会自动解析，全部都是自动化的。 在主页左侧的 网站 绑定域名。 # 分享我的免费镜像。 https://gravatar.zsh.im/avatar</description>
    </item>
    
    <item>
      <title>typecho 更换 gravatar 头像源</title>
      <link>/blog/92.html/</link>
      <pubDate>Tue, 21 Dec 2021 10:11:00 +0000</pubDate>
      
      <guid>/blog/92.html/</guid>
      <description>找到根目录下 config.inc.php 文件，在最前面加入下面的代码。 define(&amp;#39;__TYPECHO_GRAVATAR_PREFIX__&amp;#39;, &amp;#39;https://sdn.geekzu.org/avatar/&amp;#39;); 其中 https://sdn.geekzu.org/avatar/ 是一个国内源链接，这个是我目前找到的比较稳定的源。 如果这个源不能用了，可以更换其他的源，直接搜其他的相关国内源就可以了。 如果你有其他可以用的头像源，欢迎留言。 https://cravatar.cn/avatar/ https://sdn.geekzu.org/avatar/</description>
    </item>
    
  </channel>
</rss>
