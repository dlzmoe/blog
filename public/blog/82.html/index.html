<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.143.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="子舒" />
<meta property="og:url" content="https://zishu.me/blog/82.html/" />
<link rel="canonical" href="https://zishu.me/blog/82.html/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="icon" href="https://imgurl.zishu.me/favicon.ico" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://zishu.me/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zishu.me\/"
},
"articleSection" : "blog",
"name" : "揭秘箭头函数",
"headline" : "揭秘箭头函数",
"description" : " 英文地址：https:\/\/javascript.plainenglish.io\/demystifying-javascript-arrow-functions-7b2a0908a2b3\n通过掘金翻译计划活动进行翻译\n箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读这篇文章。\n现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。\n1. 语法 const arrowFunctionSyntax = () =\u0026gt; { console.log(\u0026#39;Hi, I am an arrow function\u0026#39;); }; arrowFunctionSyntax(); 在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果：\n它不包含 function 关键字。 它没有 函数名 ，这意味着这些是匿名函数。 引入了箭头 =\u0026gt; 符号。 const arrowFunctionWithOneParam = (number) =\u0026gt; number \u002b 1; const arrowFunctionWithMultipleParams = (numberOne, numberTwo) =\u0026gt; { let sum = numberOne \u002b numberTwo; return sum; }; console.log(arrowFunctionWithOneParam(5)); console.log(arrowFunctionWithMultipleParams(5, 6)); 如果我们同时观察 arrowFunctionWithOneParam 和 arrowFunctionWithMultipleParams，我们可以发现三者的不同\u0026mdash;括号 ()、块 {} 和 return 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号()。如果函数只包含一条语句，则可以忽略块{}，最后其实也可以忽略return ，如果函数只包含一个语句。\n2. 执行 const arrowFunctionExecution = () =\u0026gt; { console.log(\u0026#39;Hi, my execution is similar to normal function\u0026#39;); }; arrowFunctionExecution(); 在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 arrowFunctionExecution() 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。\n与普通函数相比，主要区别在于 this 的声明。箭头函数没有自己的 this 变量； this 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 console.log() ，并将 \u0026quot;Hi, my execution is similar to normal function\u0026quot; 打印到控制台。\n3. 作用域 const arrowFunctionScope = () =\u0026gt; { console.log(\u0026#39;Hi, my scoping rules works similar to function expression\u0026#39;); }; 这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 call、apply 和 bind 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 这篇文章。\n4. 提升 amIGoingToBeHoisted(); var amIGoingToBeHoisted = () =\u0026gt; { console.log(\u0026#39;The answer is NO\u0026#39;); }; 箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 var amIGoingToBeHoisted 将被移到顶部并使用值 undefined 进行初始化，而将初始值留在后面。在执行阶段，遇到语句amIGoingToBeHoisted 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 文章。\n",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2021",
"datePublished": "2021-11-05 00:00:00 \u002b0000 UTC",
"dateModified" : "2021-11-05 00:00:00 \u002b0000 UTC",
"url" : "https:\/\/zishu.me\/blog\/82.html\/",
"keywords" : [ "js","翻译", ]
}
</script><title>揭秘箭头函数 - 子舒的博客</title>
<meta property="og:title" content="揭秘箭头函数" />
<meta property="og:type" content="article" />
<meta property="og:description" content=" 英文地址：https://javascript.plainenglish.io/demystifying-javascript-arrow-functions-7b2a0908a2b3
通过掘金翻译计划活动进行翻译
箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读这篇文章。
现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。
1. 语法 const arrowFunctionSyntax = () =&gt; { console.log(&#39;Hi, I am an arrow function&#39;); }; arrowFunctionSyntax(); 在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果：
它不包含 function 关键字。 它没有 函数名 ，这意味着这些是匿名函数。 引入了箭头 =&gt; 符号。 const arrowFunctionWithOneParam = (number) =&gt; number &#43; 1; const arrowFunctionWithMultipleParams = (numberOne, numberTwo) =&gt; { let sum = numberOne &#43; numberTwo; return sum; }; console.log(arrowFunctionWithOneParam(5)); console.log(arrowFunctionWithMultipleParams(5, 6)); 如果我们同时观察 arrowFunctionWithOneParam 和 arrowFunctionWithMultipleParams，我们可以发现三者的不同&mdash;括号 ()、块 {} 和 return 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号()。如果函数只包含一条语句，则可以忽略块{}，最后其实也可以忽略return ，如果函数只包含一个语句。
2. 执行 const arrowFunctionExecution = () =&gt; { console.log(&#39;Hi, my execution is similar to normal function&#39;); }; arrowFunctionExecution(); 在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 arrowFunctionExecution() 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。
与普通函数相比，主要区别在于 this 的声明。箭头函数没有自己的 this 变量； this 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 console.log() ，并将 &quot;Hi, my execution is similar to normal function&quot; 打印到控制台。
3. 作用域 const arrowFunctionScope = () =&gt; { console.log(&#39;Hi, my scoping rules works similar to function expression&#39;); }; 这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 call、apply 和 bind 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 这篇文章。
4. 提升 amIGoingToBeHoisted(); var amIGoingToBeHoisted = () =&gt; { console.log(&#39;The answer is NO&#39;); }; 箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 var amIGoingToBeHoisted 将被移到顶部并使用值 undefined 进行初始化，而将初始值留在后面。在执行阶段，遇到语句amIGoingToBeHoisted 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 文章。
" />
<meta name="description" content=" 英文地址：https://javascript.plainenglish.io/demystifying-javascript-arrow-functions-7b2a0908a2b3
通过掘金翻译计划活动进行翻译
箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读这篇文章。
现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。
1. 语法 const arrowFunctionSyntax = () =&gt; { console.log(&#39;Hi, I am an arrow function&#39;); }; arrowFunctionSyntax(); 在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果：
它不包含 function 关键字。 它没有 函数名 ，这意味着这些是匿名函数。 引入了箭头 =&gt; 符号。 const arrowFunctionWithOneParam = (number) =&gt; number &#43; 1; const arrowFunctionWithMultipleParams = (numberOne, numberTwo) =&gt; { let sum = numberOne &#43; numberTwo; return sum; }; console.log(arrowFunctionWithOneParam(5)); console.log(arrowFunctionWithMultipleParams(5, 6)); 如果我们同时观察 arrowFunctionWithOneParam 和 arrowFunctionWithMultipleParams，我们可以发现三者的不同&mdash;括号 ()、块 {} 和 return 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号()。如果函数只包含一条语句，则可以忽略块{}，最后其实也可以忽略return ，如果函数只包含一个语句。
2. 执行 const arrowFunctionExecution = () =&gt; { console.log(&#39;Hi, my execution is similar to normal function&#39;); }; arrowFunctionExecution(); 在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 arrowFunctionExecution() 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。
与普通函数相比，主要区别在于 this 的声明。箭头函数没有自己的 this 变量； this 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 console.log() ，并将 &quot;Hi, my execution is similar to normal function&quot; 打印到控制台。
3. 作用域 const arrowFunctionScope = () =&gt; { console.log(&#39;Hi, my scoping rules works similar to function expression&#39;); }; 这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 call、apply 和 bind 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 这篇文章。
4. 提升 amIGoingToBeHoisted(); var amIGoingToBeHoisted = () =&gt; { console.log(&#39;The answer is NO&#39;); }; 箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 var amIGoingToBeHoisted 将被移到顶部并使用值 undefined 进行初始化，而将初始值留在后面。在执行阶段，遇到语句amIGoingToBeHoisted 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 文章。
" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon.ico" />

<link href="https://fonts.googleapis.com" rel="preconnect">
<link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="/css/primer.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
</head>

<body>
  <header class="header">
  <div class="l-wrap">
    <a href="/" class="logo">子舒（zishu.me）</a>
    <ul class="nav">
      
      <li>
        <a href="/blog/">
          <button class="btn" type="button">
            文章
          </button>
        </a>
      </li>
      
      <li>
        <a href="/categories/weekly/">
          <button class="btn" type="button">
            周刊
          </button>
        </a>
      </li>
      
      <li>
        <a href="/message/">
          <button class="btn" type="button">
            留言
          </button>
        </a>
      </li>
      
      <li><a href="/index.xml" target="_blank">
        <button class="btn" type="button">RSS</button>
      </a></li>
    </ul>
  </div>
</header>
  <section>
    <div class="l-wrap">
      <h1 class="body-title">揭秘箭头函数</h1>

      
      <div class="post-meta">
        <time> 2021/11/05</time>
      </div>
      


      
      <div class="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-语法">1. 语法</a></li>
    <li><a href="#2-执行">2. 执行</a></li>
    <li><a href="#3-作用域">3. 作用域</a></li>
    <li><a href="#4-提升">4. 提升</a></li>
  </ul>
</nav>
      </div>
      

      <article class="post-content">
        
        <blockquote>
<p>英文地址：https://javascript.plainenglish.io/demystifying-javascript-arrow-functions-7b2a0908a2b3<br>
通过掘金翻译计划活动进行翻译</p></blockquote>
<p><img src="https://imgurl.zishu.me/images/old/2021/11/05/b48745e783a796580ccd10fa6b845c71.png" alt=""></p>
<p>箭头函数是函数表达式的替代方法，但在语法上有所不同，不能在所有情况下使用。如果您还没有阅读 JavaScript 中的函数表达式，我建议您在继续阅读之前先阅读<a href="https://themallu.dev/demystifying-function-expressions">这篇文章</a>。</p>
<p>现在，让我们试着从语法、执行、作用域和提升以及代码示例方面来理解箭头函数。</p>
<h2 id="1-语法">1. 语法</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arrowFunctionSyntax</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi, I am an arrow function&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">arrowFunctionSyntax</span><span class="p">();</span>
</span></span></code></pre></div><p>在上面的代码示例中，我们可以看到箭头函数类似于函数表达式，因为它们被赋值为变量。主要区别在于函数的编写方式。以下是我们可以根据其语法从上述代码中得出的观察结果：</p>
<ol>
<li>它不包含 <strong>function</strong> 关键字。</li>
<li>它没有 <strong>函数名</strong> ，这意味着这些是匿名函数。</li>
<li>引入了箭头 <code>=&gt;</code> 符号。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arrowFunctionWithOneParam</span> <span class="o">=</span> <span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arrowFunctionWithMultipleParams</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numberOne</span><span class="p">,</span> <span class="nx">numberTwo</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">numberOne</span> <span class="o">+</span> <span class="nx">numberTwo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arrowFunctionWithOneParam</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arrowFunctionWithMultipleParams</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
</span></span></code></pre></div><p>如果我们同时观察 <code>arrowFunctionWithOneParam</code> 和 <code>arrowFunctionWithMultipleParams</code>，我们可以发现三者的不同&mdash;括号 <code>()</code>、块 <code>{}</code> 和 <code>return</code> 关键字的使用。根据箭头函数的语法，如果函数只接受一个参数，可以忽略括号<code>()</code>。如果函数只包含一条语句，则可以忽略块<code>{}</code>，最后其实也可以忽略<code>return</code> ，如果函数只包含一个语句。</p>
<h2 id="2-执行">2. 执行</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arrowFunctionExecution</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi, my execution is similar to normal function&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nx">arrowFunctionExecution</span><span class="p">();</span>
</span></span></code></pre></div><p>在执行箭头函数时，它们的执行方式与其他普通函数的执行方式相似。当 JS 引擎执行 <code>arrowFunctionExecution()</code> 时，它会创建一个函数，执行上下文并被推送到调用堆栈。一旦创建了执行上下文，它就会启动创建阶段。在这个阶段，它将创建参数对象并在其本地内存堆中声明所有变量。</p>
<p>与普通函数相比，主要区别在于 <code>this</code> 的声明。箭头函数没有自己的 <code>this</code> 变量； <code>this</code> 在箭头函数中使用时会得到词法解析。在创建阶段之后不久，执行阶段开始。这时它开始执行语句 <code>console.log()</code> ，并将 <code>&quot;Hi, my execution is similar to normal function&quot;</code> 打印到控制台。</p>
<h2 id="3-作用域">3. 作用域</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arrowFunctionScope</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hi, my scoping rules works similar to function expression&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>这些函数遵循与其他函数表达式相同的作用域规则。这些函数有自己的作用域，函数内部声明的任何变量都不能在函数外部访问。这些函数也不适用于 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法，这些方法通常依赖于作用域。如果您还没有阅读过 JavaScript 中的作用域，我建议您阅读 <a href="https://themallu.dev/demystifying-scopes"><strong>这篇文章</strong></a>。</p>
<h2 id="4-提升">4. 提升</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">amIGoingToBeHoisted</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">amIGoingToBeHoisted</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;The answer is NO&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>箭头函数没有被提升，因为它们也是函数表达式，其中函数被分配为变量的值。当 JavaScript 引擎执行上述代码时，在创建阶段，声明语句 <code>var amIGoingToBeHoisted</code> 将被移到顶部并使用值 <code>undefined</code> 进行初始化，而将初始值留在后面。在执行阶段，遇到语句<code>amIGoingToBeHoisted</code> 时会抛出类型错误，因为它的值是 undefined，这不是提升后的函数类型。要了解有关 JavaScript 提升的更多信息，我建议您阅读 <a href="https://themallu.dev/demystifying-hoisting"><strong>文章</strong></a>。</p>

        <div class="weekly-pagination"></div>
      </article>

      
      <div class="post-tags">
        
        
        <span class="namenode">分类：<a href="/categories/%E6%8A%80%E6%9C%AF">技术</a>
        </span>
        
        
        <span class="tag-node">
          
          标签：<a href="/tags/js">#js</a>
          <a href="/tags/%E7%BF%BB%E8%AF%91">#翻译</a>
          
          
        </span>
        
      </div>

      
      <div class="comments">
  <div class="giscus"></div>
</div>
<script 
  src="https://giscus.app/client.js" 
  data-repo="dlzmoe/blog" 
  data-repo-id="R_kgDOJkJvtw"
  data-category="Announcements" 
  data-category-id="DIC_kwDOJkJvt84CX9d6" 
  data-mapping="url" 
  data-strict="0"
  data-reactions-enabled="1" 
  data-emit-metadata="1" 
  data-input-position="top" 
  data-theme="fro"
  data-lang="zh-CN" 
  data-loading="lazy" 
  crossorigin="anonymous" 
  async>
</script>

      
    </div>
  </section>
  <footer class="footer">
  <div class="l-wrap">
    <p>© 2020 - 2025 Powered by
      <a href="https://github.com/dlzmoe" target="_blank">Github</a>
      / <a href="/index.xml" target="_blank">RSS</a>
    </p>
  </div>
  <div class="gotop"></div>
</footer>

<script src="/js/main.js"></script>
</body>

</html>